<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Vector Operations Back face Culling</title>
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" />
<link rel="stylesheet" type="text/css" href="/styles.css">
</head>
<body>
<div id="content" class="content">

<div id="outline-container-orgd888fde" class="outline-2">
<h2 id="orgd888fde">Back Face Culling</h2>
<div class="outline-text-2" id="text-orgd888fde">
<p>
At any given point in time you can only see 3 sides of a cube.
Currently our rendering engineering is spending alot of cpu power
rendering the sides of the cube that we wouldnt be able to see. So we
what we see is a wire frame model. If we want to save cpu cycles and
have the cube look solid we need to only render the triangles of the
mesh that are within our cone of vision. The process is called <b>BACK
FACE CULLING</b>. To perform back face culling we need to calculate the
<b>NORMAL</b> to each face. The <b>NORMAL</b> is a vector that is perpendiculiar to
the plane of the face. Once we have a normal we can determine the
distance and angle between the normal and our camera. If it is less
than 90 degrees then we should see the face.  To calculate the normal
and the distance between we need to learn vector operations.
</p>
</div>
</div>


<div id="outline-container-org0b1e4e6" class="outline-2">
<h2 id="org0b1e4e6">Vector Operations</h2>
<div class="outline-text-2" id="text-org0b1e4e6">
<ul class="org-ul">
<li>addition</li>
<li>Subtraction</li>
<li>multiplication</li>
<li>dot product</li>
<li>cross product</li>
</ul>
</div>
</div>


<div id="outline-container-org3a89140" class="outline-2">
<h2 id="org3a89140">Vector Magnitude</h2>
<div class="outline-text-2" id="text-org3a89140">
<p>
When we spoke about vectors in previously we said a vector is an arrow
that can represent a direction and a magnitude. In Common notation for
linear algebra a vector is represented in bold <b>v</b> and when we notate
magnitude as || <b>v</b> ||. In two dimensional space, we calculate the
magnitude of a vector using the pythogorean theorem. You can see how it works in
3d here. <a href="https://www.mathsisfun.com/geometry/pythagoras-3d.html">Pythogorean theorem in 3d</a>
</p>

<p class="verse">
||v|| = sq<sub>root</sub>(v.x<sup>2</sup> + v.y<sup>2</sup>).<br />
</p>

<p>
We already have A vector module. We will use these modules to add all of our operations.
We start by adding functions to get magnitude of 2d and 3d vectors. 
</p>


<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>Add to vector.h</label><pre class="src src-c">&gt;
  <span class="org-comment-delimiter">//</span><span class="org-comment">DONE: current typedef of 2d and 3d structs</span>

  <span class="org-comment-delimiter">////////////////////////////////////////////////////////////////////////////////////////</span>
  <span class="org-comment-delimiter">//</span><span class="org-comment">Declarations of Vector 2d operation functions</span>
  <span class="org-comment-delimiter">////////////////////////////////////////////////////////////////////////////////////////</span>
  <span class="org-type">float</span> vec2_length(<span class="org-type">vec2_t</span> <span class="org-variable-name">v</span>);
  <span class="org-comment-delimiter">//</span><span class="org-comment">TODO: vec2_add, vec2_sub, vec2_mul, etc...</span>

  <span class="org-comment-delimiter">////////////////////////////////////////////////////////////////////////////////////////</span>
  <span class="org-comment-delimiter">//</span><span class="org-comment">Declartions of Vector 3d operation functions</span>
  <span class="org-comment-delimiter">////////////////////////////////////////////////////////////////////////////////////////</span>
  <span class="org-type">float</span> <span class="org-function-name">vec3_length</span>(<span class="org-type">vec3_t</span> <span class="org-variable-name">v</span>);
  <span class="org-comment-delimiter">//</span><span class="org-comment">TODO: vec3_add, vec3_sub, vec3_mul, etc...</span>

  <span class="org-comment-delimiter">//</span><span class="org-comment">DONE: Declarations of  3d rotation function </span>
</pre>
</div>


<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>Add to vector.c</label><pre class="src src-c">
 <span class="org-comment-delimiter">////////////////////////////////////////////////////////////////////////////////////////</span>
 <span class="org-comment-delimiter">//</span><span class="org-comment">Impelementaion Vector 2d operation functions</span>
 <span class="org-comment-delimiter">////////////////////////////////////////////////////////////////////////////////////////</span>


 <span class="org-type">float</span> <span class="org-function-name">vec2_length</span>(<span class="org-type">vec2_t</span> <span class="org-variable-name">v</span>) {
   <span class="org-keyword">return</span> sqrt((v.x * v.x) + (v.y * v.y));
 }


 <span class="org-comment-delimiter">////////////////////////////////////////////////////////////////////////////////////////</span>
 <span class="org-comment-delimiter">//</span><span class="org-comment">Impelementaion Vector 3d operation functions</span>
 <span class="org-comment-delimiter">////////////////////////////////////////////////////////////////////////////////////////</span>

 <span class="org-type">float</span> <span class="org-function-name">vec3_length</span>(<span class="org-type">vec3_t</span> <span class="org-variable-name">v</span>) {
   <span class="org-keyword">return</span> sqrt((v.x * v.x) + (v.y * v.y) + (v.z * v.z));
 }


<span class="org-comment-delimiter">//</span><span class="org-comment">DONE: already have implementations of rotation functions here</span>
</pre>
</div>
</div>

<div id="outline-container-org6e18b49" class="outline-3">
<h3 id="org6e18b49">Note:</h3>
<div class="outline-text-3" id="text-org6e18b49">
<p>
There are many great libraries in C and C++ that have all of these functions already
implemented that are far superior to ours, and in a real production we would use those
libraries. We are reinventing the wheel so we can understand more about wheels.
</p>
</div>
</div>
</div>


<div id="outline-container-org18a88fc" class="outline-2">
<h2 id="org18a88fc">Adding and Subtracting Vectors</h2>
<div class="outline-text-2" id="text-org18a88fc">
</div>
<div id="outline-container-org2f27b69" class="outline-3">
<h3 id="org2f27b69">Adding Vectors</h3>
<div class="outline-text-3" id="text-org2f27b69">
<p>
When we add vectors, the idea is we slide the origin of <b>a</b> over to the
end of <b>b</b> The vector that is then formed by the new end of <b>a</b>
and the original origin is  <b>a</b> + <b>b</b>.
<a href="https://en.m.wikipedia.org/wiki/File:Vector_Addition.svg">Vector addition</a>
</p>

<p>
so to calculate <b>a + b</b> we just need to add a.x + b.x and a.y + b.y to get
the new vector (a + b).x and (a + b).y
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>declaration and implementation for vector addition</label><pre class="src src-c"><span class="org-comment-delimiter">//</span><span class="org-comment">declaration in vector .h</span>
  <span class="org-type">vec2_t</span> <span class="org-function-name">vec2_add</span>(<span class="org-type">vec2_t</span> <span class="org-variable-name">a</span>, <span class="org-type">vec2_t</span> <span class="org-variable-name">b</span>);  

<span class="org-comment-delimiter">//</span><span class="org-comment">implementation in vector.c</span>
 <span class="org-type">vec2_t</span> <span class="org-function-name">vec2_add</span>(<span class="org-type">vec2_t</span> <span class="org-variable-name">a</span>, <span class="org-type">vec2_t</span> <span class="org-variable-name">b</span>)
 {
   <span class="org-type">vec2_t</span> <span class="org-variable-name">result</span> = {
      .x = a.x + b.x,
      .y = a.y + b.y
   };
   <span class="org-keyword">return</span> result;
 }

</pre>
</div>
</div>
</div>

<div id="outline-container-orgfc1a62f" class="outline-3">
<h3 id="orgfc1a62f">Substracting Vectors</h3>
<div class="outline-text-3" id="text-orgfc1a62f">
<p>
When we subtract Vectors we flip the second vector to the opposite
direction and then do regular addition. We can think of it as
</p>
<pre class="example" id="orga3f23bb">
a - b = a + -(b)
</pre>
<p>
The negation of <b>b</b> is accomplished by flipping the sign of it's components.
So if b = (2,3) the negation of b = (-2,-3). We then proceed to follow the
regular addition procedure above. Slide <b>b</b> over to the end of <b>a</b> and the new
vector formed by the origin and the new end of <b>b</b> is (a-b)
<a href="http://mathlogicactivities.blogspot.com/2013/02/vector-subtraction.html">Vector Subtraction</a>
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">//</span><span class="org-comment">declaration in vector .h</span>
  <span class="org-type">vec2_t</span> <span class="org-function-name">vec2_subtract</span>(<span class="org-type">vec2_t</span> <span class="org-variable-name">a</span>, <span class="org-type">vec2_t</span> <span class="org-variable-name">b</span>);  

<span class="org-comment-delimiter">//</span><span class="org-comment">implementation in vector.c</span>
  <span class="org-type">vec2_t</span> <span class="org-function-name">vec2_subtract</span>(<span class="org-type">vec2_t</span> <span class="org-variable-name">a</span>, <span class="org-type">vec2_t</span> <span class="org-variable-name">b</span>)
 {
   <span class="org-type">vec2_t</span> <span class="org-variable-name">result</span> = {
      .x = a.x - b.x,
      .y = a.y - b.y
   };
   <span class="org-keyword">return</span> result;
 }
</pre>
</div>
</div>
</div>

<div id="outline-container-orge1ff0a5" class="outline-3">
<h3 id="orge1ff0a5"><span class="todo TODO">TODO</span> implementation for 3d</h3>
<div class="outline-text-3" id="text-orge1ff0a5">
<p>
implement these in 3d by including the z component in your calculations.
</p>
</div>
</div>
</div>




<div id="outline-container-orgf58cb4e" class="outline-2">
<h2 id="orgf58cb4e">Multiplying a vector by a scalar</h2>
<div class="outline-text-2" id="text-orgf58cb4e">
<p>
Multiplying a vector by a scalor changes the magnitude but
not the direction of the vector. A scalar can be thought of
as a single factor or value that can be applied to each component
of a vector.
<a href="https://thirdspacelearning.com/gcse-maths/geometry-and-measure/vector-multiplication/">Vector * Scalar</a>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>implementation</label><pre class="src src-c"><span class="org-type">vec2_t</span> <span class="org-function-name">vec2_mul</span>(<span class="org-type">vec2_t</span> <span class="org-variable-name">v</span>, <span class="org-type">float</span> <span class="org-variable-name">scalar</span>) {
  <span class="org-type">vec2_t</span> <span class="org-variable-name">result</span> = {
    .x = v.x * scalar,
    .y = v.y * scalar
  };
}
</pre>
</div>
</div>

<div id="outline-container-org32a5aab" class="outline-3">
<h3 id="org32a5aab"><span class="todo TODO">TODO</span> Declare and implement 2d and 3d version of multiplication</h3>
</div>
</div>

<div id="outline-container-orga9d59ee" class="outline-2">
<h2 id="orga9d59ee">Division of  a vector by a scalar</h2>
<div class="outline-text-2" id="text-orga9d59ee">
<p>
Divisions is just the opposite of multiplication it also
only affects the magnitude
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>2d implementation</label><pre class="src src-c"> <span class="org-type">vec2_t</span> <span class="org-function-name">vec2_div</span>(<span class="org-type">vec2_t</span> <span class="org-variable-name">v</span>, <span class="org-type">float</span> <span class="org-variable-name">scalar</span>) {
  <span class="org-type">vec2_t</span> <span class="org-variable-name">result</span> = {
    .x = v.x / scalar,
    .y = v.y / scalar
  };
}
</pre>
</div>
</div>
<div id="outline-container-orgca75ad1" class="outline-3">
<h3 id="orgca75ad1"><span class="todo TODO">TODO</span> Declare and implement 2d and 3d version of division</h3>
</div>
</div>

<div id="outline-container-org32c5d94" class="outline-2">
<h2 id="org32c5d94">The cross product a x b</h2>
<div class="outline-text-2" id="text-org32c5d94">
<p>
2 vectors a and b define a 2 dimensional surface in 3 dimensionsal
space. It is a slice. A surface through 3 dimensional space. To find
the <b>NORMAL</b> to that surface we use the cross product.  The normal is
the vector that is perpendiculiar to that surface. The output of a
cross product is a vector that is perpendiculiar to the two input
vectors.  That is, it gives us the Normal to a surface.
</p>

<p>
The maginitude of A X B is the <b>area</b> of the parrallelogram formed by A
and B. It is given by the formula
</p>
<pre class="example" id="orgb59470f">
||a x b|| = ||a|| * ||b|| *  theta
</pre>
<p>
where  &theta; is the angle between and b
</p>

<p>
A X B, is not the same as B X A. They both give you a Normal,
but in opposite directions.
</p>


<p>
Note: cross product can only work in 3d space.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> Cross Product (x,y,z) coordinates</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">vec a</th>
<th scope="col" class="org-left">vec b</th>
<th scope="col" class="org-left">a X b</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a<sub>x</sub></td>
<td class="org-left">b<sub>x</sub></td>
<td class="org-left">(a<sub>y</sub> * b<sub>z</sub>)  - (a<sub>z</sub> * b<sub>y</sub>)</td>
</tr>

<tr>
<td class="org-left">a<sub>y</sub></td>
<td class="org-left">b<sub>y</sub></td>
<td class="org-left">(a<sub>z</sub> * b<sub>x</sub>) -  (a<sub>x</sub> * b<sub>z</sub>)</td>
</tr>

<tr>
<td class="org-left">a<sub>z</sub></td>
<td class="org-left">b<sub>z</sub></td>
<td class="org-left">(a<sub>x</sub> * b<sub>y</sub>) -  (a<sub>y</sub> * b<sub>x</sub>)</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 2:</span> Cross Product General</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">vec a</th>
<th scope="col" class="org-left">vec b</th>
<th scope="col" class="org-left">a X b</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a<sub>1</sub></td>
<td class="org-left">b<sub>1</sub></td>
<td class="org-left">(a<sub>2</sub> * b<sub>3</sub>)  - (a<sub>3</sub> * b<sub>2</sub>)</td>
</tr>

<tr>
<td class="org-left">a<sub>2</sub></td>
<td class="org-left">b<sub>2</sub></td>
<td class="org-left">(a<sub>3</sub> * b<sub>1</sub>) -  (a<sub>1</sub> * b<sub>3</sub>)</td>
</tr>

<tr>
<td class="org-left">a<sub>3</sub></td>
<td class="org-left">b<sub>3</sub></td>
<td class="org-left">(a<sub>1</sub> * b<sub>2</sub>) -  (a<sub>2</sub> * b<sub>1</sub>)</td>
</tr>
</tbody>
</table>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 3:</span> Cross Product example</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">vec a</th>
<th scope="col" class="org-right">vec b</th>
<th scope="col" class="org-left">a X b  equation</th>
<th scope="col" class="org-right">output</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">5</td>
<td class="org-left">(-7 * 4) - (1 * 2)</td>
<td class="org-right">-30</td>
</tr>

<tr>
<td class="org-right">-7</td>
<td class="org-right">2</td>
<td class="org-left">(1 * 5) -  (1 * 4)</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">4</td>
<td class="org-left">(1 * 2) -  (-7 * 5)</td>
<td class="org-right">37</td>
</tr>
</tbody>
</table>

<p>
<a href="https://www.mathsisfun.com/algebra/vectors-cross-product.html">Vector Cross product demo</a>
</p>
</div>

<div id="outline-container-orgaab9c00" class="outline-3">
<h3 id="orgaab9c00">Deriving the normal</h3>
<div class="outline-text-3" id="text-orgaab9c00">
<p>
For us the Cross product is relevant because our models are
constructed from triangular faces. Each face is described with 3
points(vertices).  With 3 points we can derive 2 vectors, by
subtracting points. and with those 2 vectors we can derive the normal.
</p>

<p>
Given Triangle ABC, where A,B,C are the vertices of the triangle. We
can derive 2 vectors, B-A and C - A, Any 2 points can be converted
into a vector by subtracting the points. And to find the normal we
take the cross product (B-A) X (C-A). The order we take the cross
product in, will define the direction of the NORMAL. (B-A) X (C-A) is
the opposite of (C-A) X (B-A).
</p>
</div>
</div>

<div id="outline-container-org5487c57" class="outline-3">
<h3 id="org5487c57">right hand rule (direction of cross product)</h3>
<div class="outline-text-3" id="text-org5487c57">
<p>
To detrmine the direction we use the right hand rule.  The cross
product of two vectors, u and v, will itself be a vector denoted
u×v. The direction of u×v is determined by the right-hand rule: if we
point the index finger of our right hand in the direction of u and our
middle finger in the direction of v, then our thumb points in the
direction of u×v
</p>



<div class="org-src-container">
<pre class="src src-c">
<span class="org-comment-delimiter">//</span><span class="org-comment">declaration in header file</span>
  <span class="org-type">vec3_t</span> <span class="org-function-name">vec3_cross</span>(<span class="org-type">vec3_t</span> <span class="org-variable-name">a</span>, <span class="org-type">vec3_t</span> <span class="org-variable-name">b</span>);

 <span class="org-comment-delimiter">//</span><span class="org-comment">implementations</span>
<span class="org-type">vec3_t</span> <span class="org-function-name">vec3_cross</span>(<span class="org-type">vec3_t</span> <span class="org-variable-name">a</span>, <span class="org-type">vec3_t</span> <span class="org-variable-name">b</span>)
{
  <span class="org-type">vec3_t</span> <span class="org-variable-name">result</span> = {
    .x = a.y * b.z - a.z * b.y,
    .y = a.z * b.x - a.x * b.z,
    .z = a.x * b.y - a.y * b.x
  };
  <span class="org-keyword">return</span> result;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org84d1459" class="outline-2">
<h2 id="org84d1459">Dot product =&gt; a &middot; b</h2>
<div class="outline-text-2" id="text-org84d1459">
<p>
The result of the dot product is a scalar.  It is a statement of the
relationsship between 2 vectors and how they relate. a &middot; b answers the
question how much as a lies in the b direction ?  You can think of it
as a shadow being cast from one onto the other. if a and b are
perpendiculiar dot product is 0 because none of a lies in the b
direction.
</p>

<p>
<a href="https://www.youtube.com/watch?v=hojaTqbSOf4">detailed discussion of dot product</a>
</p>

<p>
<a href="https://www.youtube.com/watch?v=M5U4_l0Aoxc">dot product</a>
</p>

<p>
a &middot; b = (a<sub>x</sub> * b<sub>x</sub>) + (a<sub>y</sub> * b<sub>y</sub>)
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">//</span><span class="org-comment">vec.h declartsion</span>
<span class="org-type">float</span> <span class="org-function-name">vec3_dot</span>(<span class="org-type">vec3_t</span> <span class="org-variable-name">a</span>, <span class="org-type">vec3_t</span> <span class="org-variable-name">b</span>);

<span class="org-comment-delimiter">//</span><span class="org-comment">vec.c implementation</span>
<span class="org-type">float</span> <span class="org-function-name">vec3_dot</span>(<span class="org-type">vec3_t</span> <span class="org-variable-name">a</span>, <span class="org-type">vec3_t</span> <span class="org-variable-name">b</span>) {
  <span class="org-keyword">return</span> (a.x * b.x) + (a.y * b.y) + (a.z * b.z);

    <span class="org-comment-delimiter">// </span><span class="org-comment">we should do these for vec2_t as well</span>
}
</pre>
</div>
</div>
</div>


<div id="outline-container-orgd88c3d8" class="outline-2">
<h2 id="orgd88c3d8">Back face culling implementation</h2>
<div class="outline-text-2" id="text-orgd88c3d8">
<p>
To implement back face culling we need to know the direction each face is pointing.
The direction a face points is the same direction as it's normal vector.  We find the
normal vector by applying the cross product to the face.
</p>

<p>
Once we have the normal of the face, we can then find the vector that goes from the face
to the camera. In our design, we have the camera placed at the origin, (0, 0, 0).
</p>

<p>
If we apply the dot product to the normal and to the camera ray, the result will tell us
if the two vector are pointing in the same direction. If they are it means that the camera
can see the face. If they aren't, it means that the face is turned away from the camera and
should not be rendered.  
</p>

<p>
Here are the steps
</p>
<ul class="org-ul">
<li>Using the vertices of the face, derive 2 vectors b-a and c-a</li>
<li>find the normal vector of the face by applying the cross product
(b-a) x (c-a)</li>
<li>Find the camera ray, by subtracting the camara position from
vertex <b>A</b> of the face.</li>
<li>Find the relationship between the face normal and the camera vector,
by applying the dot product. If the result is &gt; 0 they are pointed in
the same direction and the face should be rendered.</li>
</ul>
</div>
</div>

<div id="outline-container-org1997d94" class="outline-2">
<h2 id="org1997d94">Sequence of operations</h2>
<div class="outline-text-2" id="text-org1997d94">
<div class="org-src-container">
<pre class="src src-c">
<span class="org-comment-delimiter">/* </span><span class="org-comment">GLOBAL</span><span class="org-comment-delimiter"> */</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Reset our global varaible to origin.</span>
<span class="org-type">vec3_t</span> <span class="org-variable-name">camera_position</span> = { 0, 0, 0 };
<span class="org-type">int</span> <span class="org-variable-name">t_cnt</span> = 0;
<span class="org-type">triangle_t</span> <span class="org-variable-name">triangles_to_render</span>[1000];



<span class="org-comment-delimiter">/* </span><span class="org-comment">UPDATE STATE</span><span class="org-comment-delimiter"> */</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">MAIN LOOP THRU ALL FACES</span><span class="org-comment-delimiter"> */</span>
<span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; N_MESH_FACES; i++) {
  <span class="org-type">face_t</span> <span class="org-variable-name">mesh_face</span> = mesh_faces[i];

  <span class="org-type">vec3_t</span> <span class="org-variable-name">face_vertices</span>[3];
  face_vertices[0] = mesh_vertices[mesh_face.a - 1];
  face_vertices[1] = mesh_vertices[mesh_face.b - 1];
  face_vertices[2] = mesh_vertices[mesh_face.c - 1];

  <span class="org-comment-delimiter">//</span><span class="org-comment">New array to store transformed vertices</span>
  <span class="org-type">vec3_t</span> <span class="org-variable-name">transformed_vertices</span>[3]; 

  <span class="org-comment-delimiter">/* </span><span class="org-comment">TRANSFORMAION</span><span class="org-comment-delimiter"> */</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Sub Loop, apply transformations to each vertex of the current face</span>
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; 3; j++){
    <span class="org-type">vec3_t</span> <span class="org-variable-name">transformed_vertex</span> = face_vertices[j];

    transformed_vertex = vec3_rotate_x(transformed_vertex, cube_rotation.x);
    transformed_vertex = vec3_rotate_y(transformed_vertex, cube_rotation.y);
    transformed_vertex = vec3_rotate_z(transformed_vertex, cube_rotation.z);

    <span class="org-comment-delimiter">//</span><span class="org-comment">translate the vertex away from the camera</span>
    transformed_vertex.z + 5;

    <span class="org-comment-delimiter">//</span><span class="org-comment">save transformed vertex in an array of transformed vertices </span>
    transformed_vertices[j] = transformed_vertex;
    }

  <span class="org-comment-delimiter">/* </span><span class="org-comment">BACKFACE CULLING</span><span class="org-comment-delimiter">  */</span>
  <span class="org-type">vec3_t</span> <span class="org-variable-name">vertex_a</span> = transformed_vertices[0]; <span class="org-comment-delimiter">/*    </span><span class="org-comment">A</span><span class="org-comment-delimiter">    */</span>
  <span class="org-type">vec3_t</span> <span class="org-variable-name">vertex_b</span> = transformed_vertices[1]; <span class="org-comment-delimiter">/*   </span><span class="org-comment">/ \</span><span class="org-comment-delimiter">   */</span>
  <span class="org-type">vec3_t</span> <span class="org-variable-name">vertex_c</span> = transformed_vertices[2]; <span class="org-comment-delimiter">/*  </span><span class="org-comment">C---B</span><span class="org-comment-delimiter">  */</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Get the vector subtractiono of B-A and C-A</span>
  <span class="org-type">vec3_t</span> <span class="org-variable-name">vector_ab</span> = vec3_sub(vertex_b, vertex_a);
  <span class="org-type">vec3_t</span> <span class="org-variable-name">vector_ac</span> = vec3_sub(vertex_c, vertex_a);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Compute the face normal (using corss product to find perpendiculiar vector)</span>
  <span class="org-type">vec3_t</span> <span class="org-variable-name">normal</span> = vec3_cross(vector_ab, vector_ac);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Find the vector between a point in the triangle and the camera origin.</span>
  <span class="org-type">vec3_t</span> <span class="org-variable-name">camera_ray</span> = vec3_sub(camera_position, vertex_a);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Calculate how aligned the camera ray is with the face normal (using the dot product)</span>
  <span class="org-type">float</span> <span class="org-variable-name">dot_normal_camera</span> = vec3_dot(camera_ray, normal);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Bypass triangles that are looking away from the camera by continuing to next face</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">in main loop</span>
  <span class="org-keyword">if</span> (dot_normal_camera &lt; 0 ) {
    <span class="org-keyword">continue</span>;
  }


  <span class="org-comment-delimiter">/* </span><span class="org-comment">PROJECTION</span><span class="org-comment-delimiter"> */</span>

  <span class="org-type">triangle_t</span> <span class="org-variable-name">projected_triangle</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Sub Loop, project the vertices of curent face</span>
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; 3; j++) {
    <span class="org-type">vec2_t</span> <span class="org-variable-name">projected_point</span> = perspective_project_point(transformed_vertices[j]); 

  <span class="org-comment-delimiter">/* </span><span class="org-comment">translate projected vertex to center of screen</span><span class="org-comment-delimiter"> */</span>
    projected_point.x += (window_width / 2);
    projected_point.y += (window_height / 2);

    projected_triangle.points[j] = projected_point;
  }
  <span class="org-comment-delimiter">//</span><span class="org-comment">save the projected triangle</span>
  triangles_to_render[t_cnt++] = projected_triangle;
}



<span class="org-comment-delimiter">/* </span><span class="org-comment">RENDERING 2D</span><span class="org-comment-delimiter"> */</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Iterate through your global array of triangles to render. and draw them</span>

<span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; t_cnt; i++){
  <span class="org-type">triangle_t</span> <span class="org-variable-name">triangle</span> = triangles_to_render[i];
  draw_rectangle(triangle.points[0].x, triangle.points[0].y, 5,5, 0xFF00FF00);
  draw_rectangle(triangle.points[1].x, triangle.points[1].y, 5,5, 0xFF00FF00);
  draw_rectangle(triangle.points[2].x, triangle.points[2].y, 5,5, 0xFF00FF00);
  draw_trianlge(
                triangle.points[0].x,
                triangle.points[0].y,
                triangle.points[1].x,
                triangle.points[1].y,
                triangle.points[2].x,
                triangle.points[2].y,
                0xFF00AF00);
}

t_cnt = 0;

</pre>
</div>
</div>
</div>
</div>
</body>
</html>
